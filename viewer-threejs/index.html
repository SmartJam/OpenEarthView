<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <title>My first Three.js app</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script src="node_modules/three/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/toolbox.js"></script>
    <script>
        // START initialization //
        var TILE_PROVIDER = 'http://a.tile.openstreetmap.org';
        var tileMeshes = {};
        // var TILE_PROVIDER = 'http://tilecache.openearthview.net';
        // var TILE_PROVIDER = 'http://www.localhost:8084';
        var R = 6378.137;
        var lat, lon, altitude;
        var xtile = 0;
        var ytile = 0;
        var lonOri, latOri;
        var zoom = 0;
        // var doQueue = [];
        var tileGroup;
        // var tiles = [];

        var defaultLon = 2.33517;
        var defaultLat = 48.86148;
        var defaultAlti = 150;
        var loader = new THREE.TextureLoader();
        loader.crossOrigin = '';

        var params = getSearchParameters();
        lonOri = (params.lon) ? params.lon : defaultLon;
        lon = lonOri;
        latOri = (params.lat) ? params.lat : defaultLat;
        lat = latOri;
        altitude = (params.alti) ? params.alti : defaultAlti;
        // zoom = Math.floor(Math.max(Math.min(Math.floor(28 - Math.log2(altitude)), 19), 1));
        // var xtile = long2tile(lon, zoom);
        // var ytile = lat2tile(lat, zoom);
        var url = 'http://a.tile.openstreetmap.org/' +
            Math.floor(Math.max(Math.min(Math.floor(28 - Math.log2(altitude)), 19), 1)) + '/' +
            long2tile(lon, zoom) + '/' +
            lat2tile(lat, zoom) + '.png';
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000000);

        var renderer = new THREE.WebGLRenderer();

        renderer.setSize(window.innerWidth, window.innerHeight);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        // controls = new THREE.TrackballControls(camera);
        // controls = new THREE.MouseControls(camera);
        // controls = new THREE.VRControls(camera);

        document.body.appendChild(renderer.domElement);

        var geometry = new THREE.BoxGeometry(1, 1, 1);

        // scene.add(buildAxes(100));
        var xMaterial = new THREE.MeshBasicMaterial({
            color: 0x0000FF
        });
        var yMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFF00
        });
        var zMaterial = new THREE.MeshBasicMaterial({
            color: 0xFF0000
        });
        var xAxe = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 200), xMaterial);
        xAxe.position.set(100, 0, 0);
        xAxe.rotation.set(0, 0, Math.PI / 2);
        var yAxe = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 200), yMaterial);
        yAxe.position.set(0, 100, 0);
        var zAxe = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 200, 16), zMaterial);
        zAxe.position.set(0, 0, 100);
        zAxe.rotation.set(Math.PI / 2, 0, 0);
        scene.add(xAxe);
        scene.add(yAxe);
        scene.add(zAxe);

        document.addEventListener("keydown", onDocumentKeyDown, false);

        updateScene({
            'lon': lon,
            'lat': lat,
            'alti': altitude
        });

        camera.position.z = altitude;

        function onDocumentKeyDown(event) {
            // Get the key code of the pressed key
            var keyCode = event.which;

            // 'F' - Toggle through the texture filters
            if (keyCode == 70) {
                console.log('F pressed!');
                updateScene({
                    'lon': lonOri + (controls.target.x / (1000 * R * Math.cos(lat * Math.PI / 180))) * 180 / Math.PI,
                    'lat': latOri + (controls.target.y / (1000 * R)) * 180 / Math.PI,
                });
            }
        }
        // ENDOF initialization //

        var render = function() {
            requestAnimationFrame(render);
            //////////////////////////////////////////////////////////////
            var oldZoom = zoom;
            var dist = new THREE.Vector3().copy(controls.object.position).sub(controls.target).length();
            zoom = Math.floor(Math.max(Math.min(Math.floor(26 - Math.log2(dist)), 19), 1));

            var newLon = lonOri + (controls.target.x / (1000 * R * Math.cos(lat * Math.PI / 180))) * 180 / Math.PI;
            var newLat = latOri + (controls.target.y / (1000 * R)) * 180 / Math.PI;
            var newXtile = long2tile(newLon, zoom);
            var newYtile = lat2tile(newLat, zoom);
            if (Math.abs(zoom - oldZoom) >= 1 ||
                Math.abs(newXtile - xtile) >= 1 ||
                Math.abs(newYtile - ytile) >= 1) {
                console.log('from ', oldZoom, 'to', zoom);
                console.log('lon/lat/dist: ', newLon, newLat, dist);
                updateScene({
                    'lon': newLon,
                    'lat': newLat,
                });
            }
            renderer.render(scene, camera);
        };

        render();

        function tileMeshFactory(zoom_, xtile_, ytile_) {
            var id = 'tile_' + zoom_ + '_' + xtile_ + '_' + ytile_;
            if (!(tileMeshes.hasOwnProperty(id))) {
                var lon1 = tile2long(xtile_, zoom_);
                var lat1 = tile2lat(ytile_, zoom_);
                var lon2 = tile2long(xtile_ + 1, zoom_);
                var lat2 = tile2lat(ytile_ + 1, zoom_);
                var width = measure(lat1, lon1, lat1, lon2);
                var url = TILE_PROVIDER + '/' +
                    zoom_ + '/' +
                    ((zoom_ > 0) ? (xtile_ % Math.pow(2, zoom_)) : 0) + '/' +
                    ((zoom_ > 0) ? (ytile_ % Math.pow(2, zoom_)) : 0) + '.png';
                console.log('url:', url);
                var texture = loader.load(url);
                tileMeshes[id] = new THREE.Mesh(
                    new THREE.PlaneGeometry(width, width),
                    new THREE.MeshBasicMaterial({
                        map: texture
                    })
                );
            }
            return tileMeshes[id];
        }

        function updateScene(position) {
            // Relocate a a origin to camera position
            var dist = new THREE.Vector3().copy(controls.object.position).sub(controls.target).length();
            console.log('dist:', dist);
            controls.panLeft(controls.target.x, controls.object.matrix);
            controls.panUp(-controls.target.y, controls.object.matrix);
            controls.update();
            lon = position.lon;
            lat = position.lat;
            lonOri = lon;
            latOri = lat;
            xtile = long2tile(position.lon, zoom);
            ytile = lat2tile(position.lat, zoom);

            console.log('dist/lon/lat: ', dist, '/', position.lon, '/', position.lat);
            console.log('zoom/xtile/ytile: ', zoom, '/', xtile, '/', ytile);
            var lon1 = tile2long(xtile, zoom);
            var lat1 = tile2lat(ytile, zoom);
            var lon2 = tile2long(xtile + 1, zoom);
            var lat2 = tile2lat(ytile + 1, zoom);
            var width = measure(lat1, lon1, lat1, lon2);
            var xShift = measure(lat1, lon, lat1, lon1);
            var yShift = measure(lat, lon1, lat1, lon1);
            // var height = measure(lat, lon, latP, lon);
            console.log("width: ", width);

            scene.remove(tileGroup);

            var tiles = [];
            var minXTile = Math.floor(xtile / 2) * 2;
            var maxXTile = Math.floor(xtile / 2) * 2 + 1;
            var minYTile = Math.floor(ytile / 2) * 2;
            var maxYTile = Math.floor(ytile / 2) * 2 + 1;
            console.log('minXTile/maxXTile/minYTile/maxYTile: ', minXTile, maxXTile, minYTile, maxYTile);
            for (var atile = minXTile; atile <= maxXTile; atile++) {
                for (var btile = minYTile; btile <= maxYTile; btile++) {
                    console.log('tiles[', tiles.length, ']:', 'zoom:', zoom, '/xtile:', atile, '/ytile:', btile);
                    tiles[tiles.length] = {
                        'zoom': zoom,
                        'xtile': atile,
                        'ytile': btile
                    };
                }
            }

            tileGroup = new THREE.Object3D(); //create an empty container
            var modulus = (zoom > 0) ? Math.pow(2, zoom) : 0;
            for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                // var url = TILE_PROVIDER + '/' +
                //     tile.zoom + '/' +
                //     ((zoom > 0) ? (tile.xtile % Math.pow(2, zoom)) : 0) + '/' +
                //     ((zoom > 0) ? (tile.ytile % Math.pow(2, zoom)) : 0) + '.png';
                // console.log('url:', url);

                var tileMesh = tileMeshFactory(zoom, tile.xtile, tile.ytile);
                // var texture = loader.load(url);
                // var tileMesh = new THREE.Mesh(
                //     new THREE.PlaneGeometry(width, width),
                //     new THREE.MeshBasicMaterial({
                //         map: texture
                //     })
                // );
                tileMesh.position.set(
                    (tile.xtile - xtile) * width, (ytile - tile.ytile) * width, 0);
                tileGroup.position.set(
                    (-xShift + width / 2), (yShift - width / 2), 0);
                tileGroup.add(tileMesh);
            }
            scene.add(tileGroup);
        }
    </script>
</body>

</html>
