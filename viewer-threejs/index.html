<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <title>My first Three.js app</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script src="node_modules/three/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/toolbox.js"></script>
    <script>
        // START initialization //
        var TILE_PROVIDER = 'http://a.tile.openstreetmap.org';
        // var TILE_PROVIDER = 'http://tilecache.openearthview.net';
        // var TILE_PROVIDER = 'http://localhost:8084';
        var MAX_TILEMESH = 300;
        var tileMeshes = {};
        var tileMeshQueue = [];
        var textures = {};
        var textureQueue = [];
        var R = 6378.137;
        var lat, lon, altitude;
        var xtile = 0;
        var ytile = 0;
        var lonOri, latOri;
        var zoom = 0;
        // var doQueue = [];
        var tileGroup = [];
        // var tiles = [];
        // Le louvre
        var defaultLon = 2.33517;
        var defaultLat = 48.86148;
        // Empire State Building
        // var defaultLon = -73.98563684446108;
        // var defaultLat = 40.74865445610821;


        var defaultAlti = 150;
        var loader = new THREE.TextureLoader();
        loader.crossOrigin = '';
        var jsonLoader = new THREE.ObjectLoader();
        jsonLoader.setCrossOrigin('');

        var params = getSearchParameters();
        lonOri = (params.lon) ? params.lon : defaultLon;
        lon = lonOri;
        latOri = (params.lat) ? params.lat : defaultLat;
        lat = latOri;
        altitude = (params.alti) ? params.alti : defaultAlti;
        // zoom = Math.floor(Math.max(Math.min(Math.floor(28 - Math.log2(altitude)), 19), 1));
        // var xtile = long2tile(lon, zoom);
        // var ytile = lat2tile(lat, zoom);
        var url = 'http://a.tile.openstreetmap.org/' +
            Math.floor(Math.max(Math.min(Math.floor(26 - Math.log2(altitude)), 19), 1)) + '/' +
            long2tile(lon, zoom) + '/' +
            lat2tile(lat, zoom) + '.png';
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000000);
        // var myWidth = 500;
        // var camera = new THREE.OrthographicCamera(myWidth / -2, myWidth / 2, myWidth / 2, myWidth / -2, 0.1, 100000000);

        camera.up.set(0, 0, 1);
        var renderer = new THREE.WebGLRenderer();

        renderer.setSize(window.innerWidth, window.innerHeight);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        // controls = new THREE.TrackballControls(camera);
        // controls = new THREE.MouseControls(camera);
        // controls = new THREE.VRControls(camera);

        document.body.appendChild(renderer.domElement);

        var geometry = new THREE.BoxGeometry(1, 1, 1);

        // scene.add(buildAxes(100));
        var xMaterial = new THREE.MeshBasicMaterial({
            color: 0x0000FF
        });
        var yMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFF00
        });
        var zMaterial = new THREE.MeshBasicMaterial({
            color: 0xFF0000
        });
        var xAxe = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 200), xMaterial);
        xAxe.position.set(100, 0, 0);
        xAxe.rotation.set(0, 0, Math.PI / 2);
        var yAxe = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 200), yMaterial);
        yAxe.position.set(0, 100, 0);
        var zAxe = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 200, 16), zMaterial);
        zAxe.position.set(0, 0, 100);
        zAxe.rotation.set(Math.PI / 2, 0, 0);
        // scene.add(xAxe);
        // scene.add(yAxe);
        // scene.add(zAxe);

        document.addEventListener("keydown", onDocumentKeyDown, false);

        updateScene({
            'lon': lon,
            'lat': lat,
            'alti': altitude
        });

        camera.position.z = altitude;

        function onDocumentKeyDown(event) {
            // Get the key code of the pressed key
            var keyCode = event.which;

            // 'F' - Toggle through the texture filters
            if (keyCode == 70) {
                console.log('F pressed!');
                controls.target.set(0, 0, 0);
                updateScene({
                    'lon': lonOri + (controls.target.x / (1000 * R * Math.cos(lat * Math.PI / 180))) * 180 / Math.PI,
                    'lat': latOri + (controls.target.y / (1000 * R)) * 180 / Math.PI,
                });

                // var oldZoom = zoom;
                // var dist = new THREE.Vector3().copy(controls.object.position).sub(controls.target).length();
                // zoom = Math.floor(Math.max(Math.min(Math.floor(27 - Math.log2(dist)), 19), 1));
                //
                // var newLon = lonOri + (controls.target.x / (1000 * R * Math.cos(lat * Math.PI / 180))) * 180 / Math.PI;
                // var newLat = latOri + (controls.target.y / (1000 * R)) * 180 / Math.PI;
                // var newXtile = long2tile(newLon, zoom);
                // var newYtile = lat2tile(newLat, zoom);
                // if (Math.abs(zoom - oldZoom) >= 1 ||
                //     Math.abs(newXtile - xtile) >= 1 ||
                //     Math.abs(newXtile - xtile) >= 1 ||
                //     Math.abs(newYtile - ytile) >= 1) {
                //     if (zoom > 1) {
                //         console.log('from ', oldZoom, 'to', zoom);
                //         console.log('lon/lat/dist: ', newLon, newLat, dist);
                //         updateScene({
                //             'lon': newLon,
                //             'lat': newLat,
                //         });
                //     }
                // }
            }
        }
        // ENDOF initialization //

        var render = function() {
            requestAnimationFrame(render);
            ////////////////////////////////////////////////////////////
            var oldZoom = zoom;
            var dist = new THREE.Vector3().copy(controls.object.position).sub(controls.target).length();
            zoom = Math.floor(Math.max(Math.min(Math.floor(27 - Math.log2(dist)), 19), 1));

            var newLon = lonOri + (controls.target.x / (1000 * R * Math.cos(lat * Math.PI / 180))) * 180 / Math.PI;
            var newLat = latOri + (controls.target.y / (1000 * R)) * 180 / Math.PI;
            var newXtile = long2tile(newLon, zoom);
            var newYtile = lat2tile(newLat, zoom);
            if (Math.abs(zoom - oldZoom) >= 1 ||
                Math.abs(newXtile - xtile) >= 1 ||
                Math.abs(newXtile - xtile) >= 1 ||
                Math.abs(newYtile - ytile) >= 1) {
                if (zoom > 1) {
                    console.log('from ', oldZoom, 'to', zoom);
                    console.log('lon/lat/dist: ', newLon, newLat, dist);
                    updateScene({
                        'lon': newLon,
                        'lat': newLat,
                    });
                }
            }
            renderer.render(scene, camera);
        };

        render();

        function tileMeshFactory(zoom_, xtile_, ytile_) {
            var id = 'tile_' + zoom_ + '_' + xtile_ + '_' + ytile_;
            if (!(tileMeshes.hasOwnProperty(id))) {
                var lon1 = tile2long(xtile_, zoom_);
                var lat1 = tile2lat(ytile_, zoom_);
                var lon2 = tile2long(xtile_ + 1, zoom_);
                var lat2 = tile2lat(ytile_ + 1, zoom_);
                var width = measure(lat1, lon1, lat1, lon2);
                var url = TILE_PROVIDER + '/' +
                    zoom_ + '/' +
                    ((zoom_ > 0) ? (xtile_ % Math.pow(2, zoom_)) : 0) + '/' +
                    ((zoom_ > 0) ? (ytile_ % Math.pow(2, zoom_)) : 0) + '.png';
                console.log('url:', url);
                var texture = loader.load(url);
                tileMeshes[id] = new THREE.Mesh(
                    new THREE.PlaneGeometry(width, width),
                    new THREE.MeshBasicMaterial({
                        map: texture
                    })
                );
                tileMeshQueue.push(id);
                if (tileMeshQueue.length > MAX_TILEMESH) {
                    delete tileMeshes[tileMeshQueue.shift()];
                }
            }
            return tileMeshes[id];
        }

        function textureFactory(zoom_, xtile_, ytile_) {
            var id = 'tile_' + zoom_ + '_' + xtile_ + '_' + ytile_;
            if (!(textures.hasOwnProperty(id))) {
                var url = TILE_PROVIDER + '/' +
                    zoom_ + '/' +
                    ((zoom_ > 0) ? (xtile_ % Math.pow(2, zoom_)) : 0) + '/' +
                    ((zoom_ > 0) ? (ytile_ % Math.pow(2, zoom_)) : 0) + '.png';
                textures[id] = loader.load(url);
                textureQueue.push(id);
                if (textureQueue.length > MAX_TILEMESH) {
                    delete textures[textureQueue.shift()];
                }
            }
            return textures[id];
        }

        function updateScene(position) {
            // Relocate a a origin to camera position
            var dist = new THREE.Vector3().copy(controls.object.position).sub(controls.target).length();
            console.log('dist:', dist);
            var theta = controls.getAzimuthalAngle();
            controls.panLeft(controls.target.x * Math.cos(theta) + controls.target.y * Math.sin(theta), controls.object.matrix);
            controls.panUp(-controls.target.y * Math.cos(theta) + controls.target.x * Math.sin(theta), controls.object.matrix);
            controls.update();
            controls.target.set(0, 0, 0);
            lon = position.lon;
            lat = position.lat;
            lonOri = lon;
            latOri = lat;
            xtile = long2tile(position.lon, zoom);
            ytile = lat2tile(position.lat, zoom);

            console.log('dist/lon/lat: ', dist, '/', position.lon, '/', position.lat);
            console.log('zoom/xtile/ytile: ', zoom, '/', xtile, '/', ytile);
            // // TODO test add object loaded
            // var jsonLoader = new THREE.ObjectLoader();
            // jsonLoader.setCrossOrigin('');
            //
            // // wget "localhost:8081/3dtile?format=threejs&xtile=154394&ytile=197054&zoom=19" -O ESB19_threejs.json
            // // 'json/cube.json',
            //
            //
            // jsonLoader.load(
            //     'http://localhost:8081/3dtile?format=threejs&xtile=154394&ytile=197054&zoom=19',
            //     function(obj) {
            //         // obj.rotateX(Math.PI / 2);
            //         scene.add(obj);
            //     }
            // );

            var tiles = {};
            var nextMinXtile, nextMaxXtile;
            for (var zShift = 0; zShift < 5 && (zoom - zShift > 0); zShift++) {
                scene.remove(tileGroup[zShift]);
                tileGroup[zShift] = new THREE.Object3D(); //create an empty container
                var zoom_ = zoom - zShift;
                if (zoom_ < 5 && zShift > 0) {
                    continue;
                }
                var factor = Math.pow(2, zShift);
                var xtile_ = Math.floor(xtile / factor);
                var ytile_ = Math.floor(ytile / factor);

                var lon1 = tile2long(xtile_, zoom_);
                var lat1 = tile2lat(ytile_, zoom_);
                var lon2 = tile2long(xtile_ + 1, zoom_);
                var lat2 = tile2lat(ytile_ + 1, zoom_);
                var width_ = measure(lat1, lon1, lat1, lon2);
                // console.log("width_: ", width_);
                var xShift_ = measure(lat1, lon, lat1, lon1);
                var yShift_ = measure(lat, lon1, lat1, lon1);

                // var deviation = 1;
                // // var deviation = (zShift) % 2;
                // // var deviation = 0;
                // // var deviation = 0;
                // var minXtile = Math.floor((xtile_ - deviation) / 2) * 2;
                // var maxXtile = Math.floor((xtile_ + deviation) / 2) * 2 + 1;
                // var minYtile = Math.floor((ytile_ - deviation) / 2) * 2;
                // var maxYtile = Math.floor((ytile_ + deviation) / 2) * 2 + 1;



                if (zShift == 0) {
                    var minXtile = Math.floor((xtile_) / 2) * 2;
                    var maxXtile = Math.floor((xtile_) / 2) * 2 + 1;
                    var minYtile = Math.floor((ytile_) / 2) * 2;
                    var maxYtile = Math.floor((ytile_) / 2) * 2 + 1;
                // } else if (zShift == 1) {
                //     var minXtile = Math.floor((xtile_ - 1) / 4) * 4;
                //     var maxXtile = Math.floor((xtile_ + 1) / 4) * 4 + 3;
                //     var minYtile = Math.floor((ytile_ - 1) / 4) * 4;
                //     var maxYtile = Math.floor((ytile_ + 1) / 4) * 4 + 3;
                } else {
                    var minXtile = Math.floor((xtile_ - 1) / 2) * 2;
                    var maxXtile = Math.floor((xtile_ + 1) / 2) * 2 + 1;
                    var minYtile = Math.floor((ytile_ - 1) / 2) * 2;
                    var maxYtile = Math.floor((ytile_ + 1) / 2) * 2 + 1;
                }

                // console.log('minXtile/maxXtile/minYtile/maxYtile: ', minXtile, maxXtile, minYtile, maxYtile);
                var modulus = (zoom_ > 0) ? Math.pow(2, zoom_) : 0;
                for (var atile = minXtile; atile <= maxXtile; atile++) {
                    for (var btile = minYtile; btile <= maxYtile; btile++) {
                        var id = 'z_' + zoom_ + '_' + atile + "_" + btile;
                        // var zoomNext = (zoom_ - 1);
                        // var xtileNext = Math.floor(atile / 2);
                        // var ytileNext = Math.floor(btile / 2);
                        var idNext = 'z_' + (zoom_ - 1) + '_' + Math.floor(atile / 2) + "_" + Math.floor(btile / 2);
                        tiles[idNext] = {};
                        var idNextNext = 'z_' + (zoom_ - 2) + '_' + Math.floor(atile / 4) + "_" + Math.floor(btile / 4);
                        tiles[idNextNext] = {};
                        // console.log("tiles['" + idNext + "']: {}");
                        if (!tiles.hasOwnProperty(id)) {
                            var texture = textureFactory(zoom_, atile % modulus, btile % modulus);
                            tileMesh = new THREE.Mesh(
                                new THREE.PlaneGeometry(width_ * 996 / 1000, width_ * 996 / 1000),
                                new THREE.MeshBasicMaterial({
                                    map: texture
                                })
                            );
                            tileMesh.position.set(
                                (atile - xtile_) * width_, (ytile_ - btile) * width_, 0);
                            tileGroup[zShift].position.set(
                                (-xShift_ + width_ / 2), (yShift_ - width_ / 2), 0);
                            tileGroup[zShift].add(tileMesh);

                            if (zoom_ == 19) {
                                (function(myTile, myZoom, myAtile, myBtile) {
                                    var jsonUrl = 'http://localhost:8081/3dtile?format=threejs&xtile=' + myAtile + '&ytile=' + myBtile + '&zoom=' + myZoom;
                                    console.log('jsonUrl:', jsonUrl);
                                    jsonLoader.load(
                                        // 'http://localhost:8081/3dtile?format=threejs&xtile=154394&ytile=197054&zoom=19',
                                        jsonUrl,
                                        function(obj) {
                                            myTile.add(obj);
                                        }
                                    );
                                })(tileMesh, zoom_, atile, btile);
                            }
                        }
                    }
                }
                scene.add(tileGroup[zShift]);
            }
        }
    </script>
</body>

</html>
